"use strict";(self.webpackChunkarpit_blog=self.webpackChunkarpit_blog||[]).push([[7824],{3905:function(n,e,t){t.d(e,{Zo:function(){return d},kt:function(){return p}});var i=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,i,r=function(n,e){if(null==n)return{};var t,i,r={},a=Object.keys(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var l=i.createContext({}),u=function(n){var e=i.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},d=function(n){var e=u(n.components);return i.createElement(l.Provider,{value:e},n.children)},h={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},c=i.forwardRef((function(n,e){var t=n.components,r=n.mdxType,a=n.originalType,l=n.parentName,d=s(n,["components","mdxType","originalType","parentName"]),c=u(t),p=r,f=c["".concat(l,".").concat(p)]||c[p]||h[p]||a;return t?i.createElement(f,o(o({ref:e},d),{},{components:t})):i.createElement(f,o({ref:e},d))}));function p(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var a=t.length,o=new Array(a);o[0]=c;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=n,s.mdxType="string"==typeof n?n:r,o[1]=s;for(var u=2;u<a;u++)o[u]=t[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},1639:function(n,e,t){t.r(e),t.d(e,{assets:function(){return d},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return h}});var i=t(3117),r=t(102),a=(t(7294),t(3905)),o=["components"],s={},l=void 0,u={unversionedId:"DSA/WhyThis",id:"DSA/WhyThis",title:"WhyThis",description:"Why need for DSA?",source:"@site/docs/DSA/1. WhyThis.md",sourceDirName:"DSA",slug:"/DSA/WhyThis",permalink:"/docs/DSA/WhyThis",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Advanced JS",permalink:"/docs/JS Adv/Advanced JS"},next:{title:"DoublyLinkedList",permalink:"/docs/DSA/DoublyLinkedList"}},d={},h=[{value:"Why need for DSA?",id:"why-need-for-dsa",level:2},{value:"Linked List",id:"linked-list",level:3}],c={toc:h};function p(n){var e=n.components,s=(0,r.Z)(n,o);return(0,a.kt)("wrapper",(0,i.Z)({},c,s,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"why-need-for-dsa"},"Why need for DSA?"),(0,a.kt)("p",null,"If you are reading this, than you already  know the why we need it. We are discussing a few topics here, connect with me if you want to know more"),(0,a.kt)("h3",{id:"linked-list"},"Linked List"),(0,a.kt)("p",null,"Its different from Array in terms of performance"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"No indexes"),(0,a.kt)("li",{parentName:"ol"},"can store any type of data"),(0,a.kt)("li",{parentName:"ol"},"shift and unshift takes only n(1)")),(0,a.kt)("p",null,"Linked lists are often used because of their efficient insertion and deletion. They can be used to implement stacks, queues, and other abstract data types."),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",alt:"LinkedList",src:t(8602).Z,width:"1366",height:"768"})),(0,a.kt)("p",null,"As per ",(0,a.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/implementation-linkedlist-javascript/"},"GFG")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"LinkedList is the dynamic data structure, as we can add or remove elements at ease, and it can even grow as needed. Just like arrays, linked lists store elements sequentially, but don't store the elements contiguously like an array")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"//create a node\n// A linkedList is a collection of objects which has a head and tail pointing to next objects\n// It's different from Array in terms of performance\n//1. No indexes\n//2. can store any type of data\n//3. shift and unshift takes only \n\n// Pseudoscope\n// 1. Check whether node exists\n// 2. If not create one \n// 3. Point LL's head and tail both to that node\n// 4. Implement push method\n\nclass Node {\n    constructor(value) {\n        this.value = value;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    constructor(value) {\n        const newNode = new Node(value)\n        this.head = newNode;\n        this.tail = this.head;\n        this.length = 1;\n    }\n\n    push(value) {\n        const newNodePoint = new Node(value);\n\n        if (!this.head) {\n            this.head = newNodePoint;\n            this.tail = newNodePoint;\n        } else {\n\n            this.tail.next = newNodePoint;\n            this.tail = newNodePoint;\n        }\n        this.length++;\n        return this;\n\n    }\n\n    //for popping out we need to keep track of\n    // 1. last item\n    // 2. Second last item - so that tail could be pointed to that\n    pop() {\n\n        // if no length, return undefined\n        if (!this.length)\n            return undefined;\n\n        //if length 1 , set head, tail , pre , post to null\n\n        //if length>1 then have two pointers\n        let pre = this.head;\n        let curr = this.head;\n\n        while (curr.next) {\n            pre = curr;\n            curr = curr.next;\n        }\n\n        this.tail = pre;\n        this.tail.next = null;\n        this.length--;\n\n        if (this.length === 0) {\n            this.head = null\n            this.tail = null\n        }\n        return curr;\n    }\n\n    //need to create a new node and then point node's next value to header\n    //will need a temp variable to point to curr node so that header can be pointed to it\n    unshift(value) {\n\n        let newNodePt = new Node(value);\n\n        //either use push method if node doesnt exists\n        if (!this.head)\n            return this.push(value)\n        //or you can create node and point head and tail at them\n        // this.head = this.tail = newNodePt     \n\n        newNodePt.next = this.head;\n        this.head = newNodePt;\n        this.length++\n    }\n\n    shift() {\n        if (!this.head)\n            return undefined;\n        var temp = this.head;\n        this.head = this.head.next;\n        temp.next = null;\n        this.length--;\n        if (this.length === 0) {\n            this.tail = null\n        }\n    }\n\n    get(index) {\n        if (index < 0 || index > this.length)\n            return undefined;\n\n        let curr = this.head;\n        for (let i = 0; i < index; i++) {\n            curr = curr.next\n        }\n\n        return curr;\n    }\n\n    set(value, index) {\n        if (index < 0 || index > this.length)\n            return undefined;\n        let temp = this.get(index);\n        if (temp) {\n\n            temp.value = value\n            return true\n        }\n        return false\n\n    }\n\n    insert(index, value) {\n\n        //insert from rightmost\n        if (index === this.length) {\n            return this.push(value);\n\n        }\n        //insert from leftmost\n        if (index === 0) {\n            return this.unshift(value);\n\n        }\n\n        if (index < 0 || index > this.length)\n            return undefined;\n        //insert at given index\n        let curr = this.get(index - 1);\n        const newNodePt = new Node(value);\n        newNodePt.next = curr.next;\n        curr.next = newNodePt;\n        this.length++;\n        return true;\n\n    }\n\n    remove(index) {\n        //if length is 0, return undefined\n        if (this.length === 0)\n            return undefined;\n        if (this.length === 1 && index === 1) {\n            this.tail = this.head = null;\n            return true\n        }\n\n        if (index === 0)\n            return this.shift();\n        if (index === this.length - 1)\n            return this.pop();\n        if (index < 0 || index > this.length)\n            return undefined;\n\n        const prev = this.get(index - 1)\n        const temp = prev.next;\n\n        prev.next = temp.next;\n        temp.next = null;\n        this.length--;\n        return temp;\n\n    }\n\n    //damn tricky - try writing by yourself\n    reverse() {\n        if (this.length === 0 || this.length === 1) {\n            return this;\n        }\n\n        const tempvar = this.head\n        this.head = this.tail;\n        this.tail = tempvar;\n\n        let temp = this.tail\n        let prev = null;\n        let next = null;\n\n        for (let i = 0; i < this.length; i++) {\n            next = temp.next;\n            temp.next = prev;\n            prev = temp;\n            temp = next;\n        }\n\n        return this;\n    }\n\n}\n\nconst a = new LinkedList(1);\na.push(2)\na.push(3)\na.unshift(11)\na.unshift(12)\nconsole.log(a);\n\n")))}p.isMDXComponent=!0},8602:function(n,e,t){e.Z=t.p+"assets/images/LL-Performance-chart-980d184f60ab9b01142138d2dcb7a1f3.png"}}]);