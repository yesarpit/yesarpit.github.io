"use strict";(self.webpackChunkarpit_blog=self.webpackChunkarpit_blog||[]).push([[3646],{3905:function(n,e,t){t.d(e,{Zo:function(){return h},kt:function(){return c}});var i=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,i,r=function(n,e){if(null==n)return{};var t,i,r={},o=Object.keys(n);for(i=0;i<o.length;i++)t=o[i],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(i=0;i<o.length;i++)t=o[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var a=i.createContext({}),u=function(n){var e=i.useContext(a),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},h=function(n){var e=u(n.components);return i.createElement(a.Provider,{value:e},n.children)},d={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},p=i.forwardRef((function(n,e){var t=n.components,r=n.mdxType,o=n.originalType,a=n.parentName,h=l(n,["components","mdxType","originalType","parentName"]),p=u(t),c=r,f=p["".concat(a,".").concat(c)]||p[c]||d[c]||o;return t?i.createElement(f,s(s({ref:e},h),{},{components:t})):i.createElement(f,s({ref:e},h))}));function c(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var o=t.length,s=new Array(o);s[0]=p;var l={};for(var a in e)hasOwnProperty.call(e,a)&&(l[a]=e[a]);l.originalType=n,l.mdxType="string"==typeof n?n:r,s[1]=l;for(var u=2;u<o;u++)s[u]=t[u];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}p.displayName="MDXCreateElement"},9355:function(n,e,t){t.r(e),t.d(e,{assets:function(){return h},contentTitle:function(){return a},default:function(){return c},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return d}});var i=t(3117),r=t(102),o=(t(7294),t(3905)),s=["components"],l={},a=void 0,u={unversionedId:"DSA/DoublyLinkedList",id:"DSA/DoublyLinkedList",title:"DoublyLinkedList",description:"A doubly linked list is just a linked list with additional pointer.",source:"@site/docs/DSA/2. DoublyLinkedList.md",sourceDirName:"DSA",slug:"/DSA/DoublyLinkedList",permalink:"/docs/DSA/DoublyLinkedList",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"WhyThis",permalink:"/docs/DSA/WhyThis"},next:{title:"Vulnerabilities",permalink:"/docs/Security"}},h={},d=[],p={toc:d};function c(n){var e=n.components,t=(0,r.Z)(n,s);return(0,o.kt)("wrapper",(0,i.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"A doubly linked list is just a linked list with additional pointer."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// Linked List with prev pointers\n\nclass Node {\n    constructor(value) {\n        this.value = value;\n        this.next = null;\n        this.prev = null;\n    }\n\n}\n\nclass DoublyLinkedList {\n    constructor(value) {\n        this.head = new Node(value);\n        this.tail = this.head;\n        this.length = 1;\n    }\n\n    push(value) {\n        const newNode = new Node(value);\n        if (this.length === 0) {\n            this.head = this.tail = newNode;\n        } else {\n            this.tail.next = newNode;\n            newNode.prev = this.tail\n            this.tail = newNode\n        }\n        this.length++;\n        return this;\n    }\n\n    pop() {\n        if (!this.length)\n            return undefined;\n        if (this.length === 1) {\n            this.head = 1\n            this.tail = 1\n        }\n        const temp = this.tail;\n        this.tail = this.tail.prev;\n        temp.prev = null;\n        this.tail.next = null;\n\n        this.length--;\n        return temp;\n    }\n\n    unshift(value) {\n        if (!this.length)\n            return this.push(value)\n        else {\n            const newNode = new Node(value);\n            this.head.prev = newNode\n            newNode.next = this.head;\n            this.head = newNode\n        }\n        this.length++;\n        return this;\n    }\n\n    shift() {\n        if (!this.length)\n            return undefined;\n        const temp = this.head;\n        if (this.length === 1) {\n            this.head = this.tail = null;\n        } else {\n\n            this.head = this.head.next;\n            this.head.prev = null;\n            temp.next = null;\n        }\n        this.length--;\n        return temp\n    }\n\n    //we are using more efficient get than single linked list due to pointer fwd and back\n    //we can make use of prev pointer to divide into half and traverse backword\n    get(index) {\n        if (this.length === 0)\n            return undefined;\n        let temp;\n        if (index < this.length / 2) {\n            temp = this.head;\n\n            for (let i = 0; i < index; i++) {\n                temp = temp.next;\n            }\n\n        } else {\n            temp = this.tail;\n\n            for (let i = this.length; i > index; i--) {\n                temp = temp.prev;\n            }\n        }\n        return temp\n    }\n\n    //set method is exactly same as DoublyLinkedList\n    //it calls get which is more effcient in get\n    set(value, index) {\n        if (index < 0 || index > this.length)\n            return undefined;\n        let temp = this.get(index);\n        if (temp) {\n\n            temp.value = value\n            return true\n        }\n        return false\n\n    }\n\n    insert(index, value) {\n        //insert from rightmost\n        if (index === this.length) {\n            return this.push(value);\n\n        }\n        //insert from leftmost\n        if (index === 0) {\n            return this.unshift(value);\n\n        }\n\n        if (index < 0 || index > this.length)\n            return undefined;\n        //insert at given index\n        const prev = this.get(index - 1);\n        const curr = prev.next;\n        const newNode = new Node(value);\n        prev.next = newNode;\n        newNode.prev = prev;\n        newNode.next = curr;\n        curr.prev = newNode;\n        this.length++;\n        return true\n\n    }\n\n    remove(index) {\n        if (index === 0)\n            return this.shift(value);\n        if (index === this.length)\n            return this.pop(value);\n\n        const toRemove = this.get(index);\n        toRemove.prev.next = toRemove.next;\n        toRemove.next.prev = toRemove.prev;\n        toRemove.next = toRemove.prev = null;\n        this.length--;\n        return toRemove;\n\n    }\n\n}\n\nconst a = new DoublyLinkedList(1);\na.push(2)\na.push(3)\na.push(4)\na.push(5)\na.pop()\na.unshift(101)\nconsole.log(a);\n\n\n")))}c.isMDXComponent=!0}}]);